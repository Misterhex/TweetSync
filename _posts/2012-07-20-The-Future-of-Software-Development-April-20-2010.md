---
layout: post
title: the future of software development april 20 2010
categories:
- tweets
---
*taken from [http://t.co/5T4Pg4AS](http://t.co/5T4Pg4AS)*
The Future of Software Development

April 20, 2010

I've been asked to sit on a panel regarding the future of software development. This is always risky and makes me nervous, for two reasons. First, prediction is a notoriously low successrate activity. Second, the people you always see making predictions like this are usually well past their use by date. Nevertheless, here are a collection of barelyrelated thoughts I have on that subject.

Two obvious trends are cloud computing and mobile access. They are complementary. As the number of people and devices on the net increases, our ability to shape traffic on the demand side gets worse. Spikes in demand will happen faster and reach higher levels over time. Mobile devices exacerbate the demand side problems by greatly increasing both the number of people on the net and the fraction of their time they are able to access it.

Large traffic volumes both create and demand large data. Our tools for processing tera and petabyte datasets will improve dramatically. MapReduce computing a la Hadoop has created attention and excitement in this space, but it is ultimately just one tool among many. We need better languages to help us think and express large data problems. In particular, we need a language that makes big data processing accessible to people with little background in statistics or algorithms.

Speaking of languages, many of the problems we face today cannot be solved inside a single language or application. The behavior of a web site today cannot be adequately explained or reasoned about just by examining the application code. Instead, a site picks up attributes of behavior from a multitude of sources application code, web server configuration, edge caching servers, data grid servers, offline or asynchronous processing, machine learning elements, active network devices such as application firewalls, and data stores. Programming as we would describe it todaycoding application behavior in a request handlerdefines a diminishing portion of the behavior. We lack tools or languages to express and reason about these distributed, extended, fragmented systems. Consequently, it is difficult to predict the functionality, performance, capacity, scalability, and availability of these systems.

Some of this will be mitigated naturally as applicationspecific functions disappear into tools and frameworks. Companies innovating at the leading edge of scalability today are doing things in applicationspecific behavior to compensate for deficiencies in tools and platforms. For example, caching servers could arguably disappear into storage engines and noone would complain. In other words, don't count the database vendors out yet. You'll see keyvalue stores and inmemory data grid features popping up in relational databases any day now.

In general, it appears that Objects will diminish as a programming paradigm. Objectoriented programming will still exist... I'm not claiming the death of objects or something silly like that. However, OO will become just one more paradigm among several, rather than the dominant paradigm it has been for the last 15 years. Object oriented will no longer be synonymous with good.

Some people have talked about polyglot programming. I think this is a red herring. Polylgot is a reality, but it should not be a goal. That is, programmers should know many languages and paradigms, but deliberately mixing languages in a single application should be avoided. What I think we will find instead is mixing of paradigms, supported by a single primary language, with adjunct languages used only as needed for specialized functions. For example, an application written in Scala may mix OO, functional, and actorbased concepts, and it may have portions of behavior expressed in SQL and Javascript. Nevertheless, it will still primarily be a Scala application. The fact that Groovy, Scala, Clojure, and Java all run on Java Virtual Machine shouldn't mislead us into thinking that they are interchangeable... or even interoperable!

Regarding Java. I fear that Java will have to be abandoned to the Enterprise Development world. It will be relegated to the hands of cutrate business coders bashing out their gray business applications for 30  hour. We've passed the tipping point on this one. We used to joke that Java would be the next COBOL, but that doesn't seem as funny now that it's true. Java will continue to exist. Millions of lines of it will be written each year. It won't be the driver of innovation, though. As individual programmers, I'd recommend that you learn another language immediately and differentiate yourself from the hordes of lowskill, lowrent outsource coders that will service the mainstream Java consumer.

Where will innovation come from? Although some of the blush seems to be coming off Ruby, the reduction in hype has mainly allowed Ruby and Ruby on Rails developers to knuckle down and produce. That community continues to drive tremendous innovation. Many of the interesting developments here relate to process. Ruby developers have given us fantastic tools like Gems and Capistrano, that let small teams outperform and outproduce groups four times their size.

To my great surprise, data storage has become a hotbed of innovation in the last few years. Some of this is driven by the highscalability fetishists, which is probably the wrong reason for 98 of companies and teams. However, innovations around column stores, graph databases, and keyvalue stores offer developers new tools to reduce the impedance mismatch between their data storage and their programming language. We spent twenty years trying to squeeze objects into relational databases. Aside from the object databases, which were an early casualty of Oracle's ascension, we mostly focused on changing the application code through framework after framework and ORM after ORM. It's refreshing to see storage models that are easier to use and easier to modify.

This will also cause another flurry of reactive innovation from the database vendors, just as we saw with Universal Databases in the mid90s. The big players hereMicrosoft and Oraclewon't let some schemaless little upstarts erode their market share. More significantly, they aren't about to let their flagship productsand the ones which give them beachheads inside every major corporationget intermediated by some opensource frameworks banged up by the social network giants. Look for big moves by these vendors into high scalability, agile storage, and eventual consistency storage.

